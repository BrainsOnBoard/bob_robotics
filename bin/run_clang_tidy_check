#!/usr/bin/python3
# Runs clang-tidy over the bob_robotics repo to find the specified warnings and
# converts the results into a Jenkins-readable XML file. One or more
# compile_commands.json files should be present somewhere in the tree (they
# don't have to be committed to git). These can be generated by CMake by passing
# the argument -DCMAKE_EXPORT_COMPILE_COMMANDS=1.
#
# If the argument --generate-fixes is passed to this script, then it will
# deposit a series of YAML files into ./clang_tidy_fixes. These can then be
# applied like so:
#       clang-apply-replacements ./clang_tidy_fixes
#
# Note that only a small subset of the checks are actually capable of generating
# fixes at present (though most of the modernize-* checks seem to work).

import glob
import itertools
import json
import multiprocessing as mp
import os
import shutil
import subprocess
import sys
from xml.sax.saxutils import escape

INCLUDE_CHECKS = (
    'bugprone-*',
    'clang-analyzer-*',
    'concurrency-*',
    'misc-*',
    'modernize-*',
    'performance-*',
    'readability-*',
)

# Some of these are a bit overzealous...
EXCLUDE_CHECKS = (
    '*osx.*',
    'bugprone-branch-clone',
    'bugprone-exception-escape',
    'bugprone-integer-division',
    'bugprone-macro-parentheses',
    'bugprone-narrowing-conversions',
    'concurrency-mt-unsafe',
    'clang-analyzer-webkit*',
    'misc-non-private-member-variables-in-classes',
    'modernize-avoid-c-arrays',
    'modernize-concat-nested-namespaces',
    'modernize-pass-by-value',
    'modernize-use-auto',
    'modernize-use-emplace',
    'modernize-use-equals-default',
    'modernize-use-nodiscard',
    'modernize-raw-string-literal',
    'modernize-use-trailing-return-type',
    'performance-type-promotion-in-math-fn',
    'readability-braces-around-statements',
    'readability-convert-member-functions-to-static',
    'readability-else-after-return',
    'readability-function-cognitive-complexity',
    'readability-implicit-bool-conversion',
    'readability-isolate-declaration',
    'readability-magic-numbers',
    'readability-make-member-function-const',
    'readability-named-parameter',
    'readability-static-accessed-through-instance',
    'readability-uppercase-literal-suffix',
    'readability-qualified-auto',
)
check_args = None

# If the user passes -checks=[something] as an argument, use this instead of our
# own default checks
for arg in sys.argv[1:]:
    if arg.startswith('-checks='):
        check_args = arg

if check_args is None and (INCLUDE_CHECKS or EXCLUDE_CHECKS):
    checks = itertools.chain(INCLUDE_CHECKS, ('-' + check for check in EXCLUDE_CHECKS))
    check_args = '-checks=' + ','.join(checks)

# List the currently enabled checks
args = ['/usr/bin/clang-tidy', '-list-checks']
if check_args:
    args.append(check_args)
subprocess.run(args)

FIXES_DIR = 'clang_tidy_fixes'
if os.path.exists(FIXES_DIR):
    shutil.rmtree(FIXES_DIR)
os.mkdir(FIXES_DIR)

def run_clang_tidy(file):
    args = ['/usr/bin/clang-tidy', '-p', '.', file]

    # Explicitly (disallow) various checks
    if check_args:
        args.append(check_args)

    # Generate fixes
    fixes_file = os.path.join(FIXES_DIR, file.replace('/', '_') + '.yaml')
    args.append('--export-fixes=' + fixes_file)

    proc = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout = proc.communicate()[0].decode('utf-8')
    if stdout != '':
        print(stdout)

if __name__ == '__main__':
    all_json = []
    all_files = set()
    cwd = os.getcwd() + '/'
    exclude_path = os.path.join(cwd, 'third_party')

    for filepath in glob.glob('**/compile_commands.json', recursive=True):
        # If it's in the root folder then it's our output file...
        if filepath == 'compile_commands.json':
            continue

        print('Found ' + filepath)
        with open(filepath, 'r') as file:
            for cmd in json.load(file):
                # Don't add duplicate files
                if not cmd['file'].startswith(exclude_path) and not cmd['file'] in all_files:
                    all_files.add(cmd['file'])
                    all_json.append(cmd)

    # Check we found at least one compile_commands.json
    assert len(all_json) > 0
    print()

    # Save concatenated JSON to a combined file
    with open('compile_commands.json', 'w') as file:
        json.dump(all_json, file)

    print('Running clang-tidy on the following files:')
    for filepath in sorted(filepath.replace(cwd, '') for filepath in all_files):
        print('\t' + filepath)

    # Run clang-tidy in parallel over source files and concatenate output
    with mp.Pool() as pool:
        pool.map(run_clang_tidy, all_files)

    # Remove the folder if it's empty
    try:
        os.rmdir('clang_tidy_fixes')
    except:
        pass
