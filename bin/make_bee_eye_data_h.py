#!/usr/bin/python
# This script generates bee_eye_data.h, which contains an array giving the pixel
# map to transform a regular image into the bee's-eye view using the Giger
# model.
#
# Code from Alex Cope.

from __future__ import print_function
import math
import numpy
import sys

if len(sys.argv) < 2:
    print("usage: make_bee_eye_h.py OUTPUT_WIDTH OUTPUT_HEIGHT [--plot]")
    exit(1)

doplot = len(sys.argv) >= 4 and sys.argv[3] == '--plot'

im_size = (int(sys.argv[1]), int(sys.argv[2]))
eye_size = (140, 100)
outfile = 'bee_eye_data.h'

def vert(x):
    return (0.000734 * (x ** 2))-(0.1042253 * x) + 4.9

def horr(x):
    if x > 60:
        return (0.00037 * (x ** 2))-(0.04462 * x) + 3.438
    else:
        return (0.00069 * (x ** 2))-(0.08333 * x) + 4.6

def radialDistortion(x, y):
    camYaw = 0.0 / 180.0 * math.pi
    camPitch = 0.0 / 180.0 * math.pi
    camRoll = 0.0 / 180.0 * math.pi
    camTrans = numpy.array([[0], [0], [0]])
    camScaling = 1
    camYM = numpy.matrix([[math.cos(camYaw), 0, math.sin(camYaw)], [0, 1, 0], [-math.sin(camYaw), 0, math.cos(camYaw)]])
    camPM = numpy.matrix([[1, 0, 0], [0, math.cos(camPitch), -math.sin(camPitch)], [0, math.sin(camPitch), math.cos(camPitch)]])
    camRM = numpy.matrix([[math.cos(camRoll), -math.sin(camRoll), 0], [math.sin(camRoll), math.cos(camRoll), 0], [0, 0, 1]])

    # undo the camera rotation
    # convert x,y into rotations
    x = (x - eye_size[1] / 2) / 180 * math.pi
    y = (y - eye_size[0] / 2) / 180 * math.pi
    ommYM = numpy.matrix([[math.cos(x), 0, math.sin(x)], [0, 1, 0], [-math.sin(x), 0, math.cos(x)]])
    ommPM = numpy.matrix([[1, 0, 0], [0, math.cos(y), -math.sin(y)], [0, math.sin(y), math.cos(y)]])
    forwardVect = numpy.array([[0], [0], [1]])
    vect2 = ommYM * ommPM * forwardVect
    vect2 = vect2 + camTrans
    vect2 = camYM * camPM * camRM * vect2
    if (vect2[2] > 0.05):
        vect2 = vect2 * camScaling / vect2[2]
    else:
        return numpy.array([[100000], [100000], [1]])

    # normalise
    # now translate x-y into pixels to account for distortion
    r_c = math.sqrt((vect2[0]) ** 2 + (vect2[1]) ** 2)
    k_1 = -0.3112
    k_2 = 0.10422
    k_3 = 0
    vect2[0] = vect2[0] * (1 + k_1 * r_c ** 2 + k_2 * r_c ** 4 + k_3 * r_c ** 6)
    vect2[1] = vect2[1] * (1 + k_1 * r_c ** 2 + k_2 * r_c ** 4 + k_3 * r_c ** 6)

    # camera matrix:
    f_x = 187.93014
    f_y = 170.79432
    s = 0
    c_x = 185.139 * 2.0
    c_y = 111.64043 * 2.0
    camMat = numpy.matrix([[f_x, s, c_x], [0, f_y, c_y], [0, 0, 1]])

    # apply
    vect2 = camMat * vect2
    return vect2

startX = 60
startY = 70

startPixX = 34
startPixY = 54

currX = startX
currY = startY

currPixX = startPixX
currPixY = startPixY

itr = 0

xPoints = []
yPoints = []
xPix = []
yPix = []

scale = 1.0
scaleV = 1.0

while currY < eye_size[0]:

    if (itr % 2) == 0:
        currX += (0.5 * horr(currY) * scale)

    while currX < eye_size[1]:
        xPoints.append(currX)
        yPoints.append(currY)
        xPix.append(currPixX)
        yPix.append(currPixY)
        currX += horr(currY) * scale
        currPixX += 1
    currX = startX
    currPixX = startPixX

    if (itr % 2) == 0:
        currX += (0.5 * horr(currY) * scale)

    while currX > -20:
        currX -= horr(currY) * scale
        currPixX -= 1
        xPoints.append(currX)
        yPoints.append(currY)
        xPix.append(currPixX)
        yPix.append(currPixY)
    currX = startX
    currPixX = startPixX
    currY += vert(currX) * scale * scaleV
    currPixY += 1
    itr += 1
currY = startY
currPixY = startPixY

itr = 0

while currY > 0:

    if (itr % 2) == 0:
        currX += (0.5 * horr(currY) * scale)

    while currX < eye_size[1]:
        xPoints.append(currX)
        yPoints.append(currY)
        xPix.append(currPixX)
        yPix.append(currPixY)
        currX += horr(currY) * scale
        currPixX += 1
    currX = startX
    currPixX = startPixX

    if (itr % 2) == 0:
        currX += (0.5 * horr(currY) * scale)

    while currX > -20:
        currX -= horr(currY) * scale
        currPixX -= 1
        xPoints.append(currX)
        yPoints.append(currY)
        xPix.append(currPixX)
        yPix.append(currPixY)
    currX = startX
    currPixX = startPixX
    currY -= vert(currX) * scale * scaleV
    currPixY -= 1
    itr += 1

print("Generating " + outfile)
f = open(outfile, 'w')

orderedCoords = sorted(zip(xPoints, yPoints, xPix, yPix))
f.write("#pragma once\n" +
        "// This file was automatically generated by bin/make_bee_eye_h.py\n\n" +
        "namespace BoBRobotics {\n" +
        "namespace ImgProc {\n" +
        "namespace BeeEye {\n" +
        "constexpr float EyeData[][4] = {")

count = 0
mooX = []
mooX2 = []
mooY = []
mooY2 = []
mooXN2 = []
mooZ = []
for elem in orderedCoords:
    # convert angles
    v = radialDistortion(elem[0], elem[1])
    if v[0].min() > 0.0 and v[0].min() < im_size[0] and v[1].min() > 0.0 and v[1].min() < im_size[1]:
        mooX.append(v[0].min())
        mooX2.append(elem[0])
        mooY.append(v[1].min())
        mooY2.append(elem[1])
        mooXN2.append(-elem[0])
        mooZ.append(v[2].min())
        f.write("{" + str(im_size[0]-1-round(v[0].min())) + "," + str(im_size[1]-1-round(v[1].min())) + "," + str(elem[2]) + "," + str(elem[3]) + "},")
        count += 1

f.write("};\n" +
        "constexpr int EyeDataLength = %d;\n" % count +
        "constexpr int ImageSize[2] = { %d, %d };\n" % im_size +
        "constexpr int EyeSize[2] = { %d, %d };\n" % eye_size +
        "} // BeeEye\n" +
        "} // ImgProc\n" +
        "} // BoBRobotics\n")
f.close()

if doplot:
    import matplotlib.pyplot as plt

    fig1 = plt.figure(figsize=(8, 6))
    plt.plot(mooX, mooY, 'r.')
    plt.axis([0, im_size[0], 0, im_size[1]])
    plt.xlabel("X pixel location", fontsize="20");
    plt.ylabel("Y pixel location", fontsize="20");
    plt.show()

    fig2 = plt.figure(figsize=(12, 6))
    plt.plot(xPoints, yPoints, 'g.')
    xPoints2 = [-x for x in xPoints]
    plt.plot(xPoints2, yPoints, 'g.')
    plt.plot(mooX2, mooY2, 'r.')
    plt.plot(mooXN2, mooY2, 'b.')
    plt.xlabel("Azimuth (degrees)", fontsize="20");
    plt.ylabel("Elevation (degrees)", fontsize="20");
    plt.show()
