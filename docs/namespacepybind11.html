<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BoB robotics: pybind11 Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="bob_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">BoB robotics
   </div>
   <div id="projectbrief">The Brains on Board robotics library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacepybind11.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">pybind11 Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>glibc defines I as a macro which breaks things, e.g., boost template names  
<a href="namespacepybind11.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1arg.html">arg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1arg__v.html">arg_v</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1args.html">args</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1arithmetic.html">arithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation to mark enums as an arithmetic type.  <a href="structpybind11_1_1arithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1array.html">array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1array__t.html">array_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1base.html">base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation indicating that a class derives from another given type.  <a href="structpybind11_1_1base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1bool__.html">bool_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1buffer.html">buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1buffer__info.html">buffer_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information record describing a Python buffer object.  <a href="structpybind11_1_1buffer__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1buffer__protocol.html">buffer_protocol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation which enables the buffer protocol for a type.  <a href="structpybind11_1_1buffer__protocol.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1bytearray.html">bytearray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1bytes.html">bytes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1call__guard.html">call_guard</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1call__guard_3_01T_01_4.html">call_guard&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1call__guard_3_01T_00_01Ts_8_8_8_01_4.html">call_guard&lt; T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1call__guard_3_4.html">call_guard&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1capsule.html">capsule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1class__.html">class_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1cpp__function.html">cpp_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an arbitrary C++ function/method/lambda function/.. into a callable Python object.  <a href="classpybind11_1_1cpp__function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1custom__type__setup.html">custom_type_setup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1dict.html">dict</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1doc.html">doc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation for documentation.  <a href="structpybind11_1_1doc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1dtype.html">dtype</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1dynamic__attr.html">dynamic_attr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation which enables dynamic attributes, i.e. adds <code>__dict__</code> to a class.  <a href="structpybind11_1_1dynamic__attr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1ellipsis.html">ellipsis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1enum__.html">enum_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds C++ enumerations and enumeration classes to Python.  <a href="classpybind11_1_1enum__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1error__scope.html">error_scope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII wrapper that temporarily clears any Python error state.  <a href="structpybind11_1_1error__scope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1exception.html">exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1float__.html">float_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor.html">format_descriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor_3_01char_0fN_0e_4.html">format_descriptor&lt; char[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor_3_01std_1_1array_3_01char_00_01N_01_4_01_4.html">format_descriptor&lt; std::array&lt; char, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor_3_01std_1_1complex_3_01T_01_4_00_01detail_1_1enable__if__t_335bd2dee28f89d65b53a5265f18b54a.html">format_descriptor&lt; std::complex&lt; T &gt;, detail::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor_3_01T_00_01detail_1_1enable__if__t_3_01detail_1_1array__inff53a1b36e372aeab711589cada4b3062.html">format_descriptor&lt; T, detail::enable_if_t&lt; detail::array_info&lt; T &gt;::is_array &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor_3_01T_00_01detail_1_1enable__if__t_3_01detail_1_1is__pod__sd2aee290da218819650054b8c635a2ec.html">format_descriptor&lt; T, detail::enable_if_t&lt; detail::is_pod_struct&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor_3_01T_00_01detail_1_1enable__if__t_3_01std_1_1is__arithmetic_3_01T_01_4_1_1value_01_4_01_4.html">format_descriptor&lt; T, detail::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1format__descriptor_3_01T_00_01detail_1_1enable__if__t_3_01std_1_1is__enum_3_01T_01_4_1_1value_01_4_01_4.html">format_descriptor&lt; T, detail::enable_if_t&lt; std::is_enum&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1function.html">function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1gil__scoped__acquire.html">gil_scoped_acquire</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1gil__scoped__release.html">gil_scoped_release</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1handle.html">handle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1int__.html">int_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1is__final.html">is_final</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation for classes that cannot be subclassed.  <a href="structpybind11_1_1is__final.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1is__method.html">is_method</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation for methods.  <a href="structpybind11_1_1is__method.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1is__operator.html">is_operator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation for operators.  <a href="structpybind11_1_1is__operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1iterable.html">iterable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1iterator.html">iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1keep__alive.html">keep_alive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep patient alive while nurse lives.  <a href="structpybind11_1_1keep__alive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1kw__only.html">kw_only</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1kwargs.html">kwargs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1list.html">list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1memoryview.html">memoryview</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1metaclass.html">metaclass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation which requests that a special metaclass is created for a type.  <a href="structpybind11_1_1metaclass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1module__.html">module_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for Python extension modules.  <a href="classpybind11_1_1module__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1module__local.html">module_local</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation that marks a class as local to the module:  <a href="structpybind11_1_1module__local.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1multiple__inheritance.html">multiple_inheritance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation indicating that a class is involved in a multiple inheritance relationship.  <a href="structpybind11_1_1multiple__inheritance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1name.html">name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation for function names.  <a href="structpybind11_1_1name.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1nodelete.html">nodelete</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy destructor wrapper that can be used to expose classes with a private destructor.  <a href="structpybind11_1_1nodelete.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1none.html">none</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1object.html">object</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1options.html">options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1overload__cast.html">overload_cast</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1polymorphic__type__hook.html">polymorphic_type_hook</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1polymorphic__type__hook_3_01itype_00_01detail_1_1enable__if__t_3_01std_1_1is__ede351517968b3a3b6566f6ef10d55b6.html">polymorphic_type_hook&lt; itype, detail::enable_if_t&lt; std::is_base_of&lt; Animal, itype &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1polymorphic__type__hook__base.html">polymorphic_type_hook_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1polymorphic__type__hook__base_3_01itype_00_01detail_1_1enable__if__t_3_01std_1a2eae5d0afc46e0f2c8bff4143842390.html">polymorphic_type_hook_base&lt; itype, detail::enable_if_t&lt; std::is_polymorphic&lt; itype &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1pos__only.html">pos_only</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1prepend.html">prepend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a function for addition at the beginning of the existing overload chain instead of the end.  <a href="structpybind11_1_1prepend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1scope.html">scope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation for parent scope.  <a href="structpybind11_1_1scope.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1scoped__estream__redirect.html">scoped_estream_redirect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1scoped__interpreter.html">scoped_interpreter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1scoped__ostream__redirect.html">scoped_ostream_redirect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1sequence.html">sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1set.html">set</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpybind11_1_1sibling.html">sibling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotation indicating that a function is an overload associated with a given "sibling".  <a href="structpybind11_1_1sibling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1slice.html">slice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1staticmethod.html">staticmethod</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1str.html">str</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1tuple.html">tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1type.html">type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpybind11_1_1weakref.html">weakref</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa14f653ec1b63f58b3013ef9d6ac9422"><td class="memTemplParams" colspan="2"><a id="aa14f653ec1b63f58b3013ef9d6ac9422" name="aa14f653ec1b63f58b3013ef9d6ac9422"></a>
template&lt;typename &gt; </td></tr>
<tr class="memitem:aa14f653ec1b63f58b3013ef9d6ac9422"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>arg_t</b> = <a class="el" href="structpybind11_1_1arg__v.html">arg_v</a></td></tr>
<tr class="memdesc:aa14f653ec1b63f58b3013ef9d6ac9422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for backward compatibility &ndash; to be removed in version 2.0. <br /></td></tr>
<tr class="separator:aa14f653ec1b63f58b3013ef9d6ac9422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e3d317b399f8925c3b9f1980018481"><td class="memItemLeft" align="right" valign="top"><a id="a51e3d317b399f8925c3b9f1980018481" name="a51e3d317b399f8925c3b9f1980018481"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ssize_t</b> = Py_ssize_t</td></tr>
<tr class="separator:a51e3d317b399f8925c3b9f1980018481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74292751b6fc8fe14d7c6772ae2fd0fc"><td class="memItemLeft" align="right" valign="top"><a id="a74292751b6fc8fe14d7c6772ae2fd0fc" name="a74292751b6fc8fe14d7c6772ae2fd0fc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_t</b> = std::size_t</td></tr>
<tr class="separator:a74292751b6fc8fe14d7c6772ae2fd0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f50dab2af5c143a3d9b75dd45e992b7"><td class="memItemLeft" align="right" valign="top"><a id="a9f50dab2af5c143a3d9b75dd45e992b7" name="a9f50dab2af5c143a3d9b75dd45e992b7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ExceptionTranslator</b> = void(*)(std::exception_ptr)</td></tr>
<tr class="separator:a9f50dab2af5c143a3d9b75dd45e992b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1dc06329bd734b9632f108e2006e25"><td class="memItemLeft" align="right" valign="top"><a id="a9c1dc06329bd734b9632f108e2006e25" name="a9c1dc06329bd734b9632f108e2006e25"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EigenDStride</b> = Eigen::Stride&lt; Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:a9c1dc06329bd734b9632f108e2006e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23484f7bb5fa23363d338c66c71dc6a8"><td class="memTemplParams" colspan="2"><a id="a23484f7bb5fa23363d338c66c71dc6a8" name="a23484f7bb5fa23363d338c66c71dc6a8"></a>
template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a23484f7bb5fa23363d338c66c71dc6a8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenDRef</b> = Eigen::Ref&lt; MatrixType, 0, EigenDStride &gt;</td></tr>
<tr class="separator:a23484f7bb5fa23363d338c66c71dc6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f353deb5dca5ef06dd63358f9a9bb20"><td class="memTemplParams" colspan="2"><a id="a6f353deb5dca5ef06dd63358f9a9bb20" name="a6f353deb5dca5ef06dd63358f9a9bb20"></a>
template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a6f353deb5dca5ef06dd63358f9a9bb20"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenDMap</b> = Eigen::Map&lt; MatrixType, 0, EigenDStride &gt;</td></tr>
<tr class="separator:a6f353deb5dca5ef06dd63358f9a9bb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad952f3f47afb586cdc0f250f70f0a565"><td class="memItemLeft" align="right" valign="top"><a id="ad952f3f47afb586cdc0f250f70f0a565" name="ad952f3f47afb586cdc0f250f70f0a565"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>module</b> = <a class="el" href="classpybind11_1_1module__.html">module_</a></td></tr>
<tr class="separator:ad952f3f47afb586cdc0f250f70f0a565"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a5f83e7a05cee9068927633ac47dbe69c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">return_value_policy</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca2bd9c0ed00116be1258e0cc66617d7c8">automatic</a> = 0
, <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca1c1628c22d69b3b9bac4b5c3674852e3">automatic_reference</a>
, <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca5dc4bb19391b04351f49572019c628c0">take_ownership</a>
, <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca12cba3ee81cf4a793796a51b6327c678">copy</a>
, <br />
&#160;&#160;<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca3734a903022249b3010be1897042568e">move</a>
, <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69cab8af13ea9c8fe890c9979a1fa8dbde22">reference</a>
, <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69caa39bc0596cb125c1605a78fbd287df7f">reference_internal</a>
<br />
 }</td></tr>
<tr class="memdesc:a5f83e7a05cee9068927633ac47dbe69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approach used to cast a previously unknown C++ instance into a Python object.  <a href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">More...</a><br /></td></tr>
<tr class="separator:a5f83e7a05cee9068927633ac47dbe69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a5898f9a083026531bc5d435f715ea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a08a5898f9a083026531bc5d435f715ea">eval_mode</a> { <a class="el" href="namespacepybind11.html#a08a5898f9a083026531bc5d435f715eaa86e05cca1e5516b3ff4014f9af34aaff">eval_expr</a>
, <a class="el" href="namespacepybind11.html#a08a5898f9a083026531bc5d435f715eaa9cf39a293befe652b5046b1e7cf9fe58">eval_single_statement</a>
, <a class="el" href="namespacepybind11.html#a08a5898f9a083026531bc5d435f715eaa22b140993f208620cf25bba6e0d5590b">eval_statements</a>
 }</td></tr>
<tr class="separator:a08a5898f9a083026531bc5d435f715ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ade1f8946c805279f41d7f6eed0d4f07d"><td class="memTemplParams" colspan="2"><a id="ade1f8946c805279f41d7f6eed0d4f07d" name="ade1f8946c805279f41d7f6eed0d4f07d"></a>
template&lt;typename T , detail::enable_if_t&lt;!detail::is_pyobject&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ade1f8946c805279f41d7f6eed0d4f07d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cast</b> (const <a class="el" href="classpybind11_1_1handle.html">handle</a> &amp;<a class="el" href="classpybind11_1_1handle.html">handle</a>)</td></tr>
<tr class="separator:ade1f8946c805279f41d7f6eed0d4f07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999fd9c72081111a7dbe943398f6d42f"><td class="memTemplParams" colspan="2"><a id="a999fd9c72081111a7dbe943398f6d42f" name="a999fd9c72081111a7dbe943398f6d42f"></a>
template&lt;typename T , detail::enable_if_t&lt;!detail::is_pyobject&lt; T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a999fd9c72081111a7dbe943398f6d42f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cast</b> (T &amp;&amp;value, <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">return_value_policy</a> policy=<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca1c1628c22d69b3b9bac4b5c3674852e3">return_value_policy::automatic_reference</a>, <a class="el" href="classpybind11_1_1handle.html">handle</a> parent=<a class="el" href="classpybind11_1_1handle.html">handle</a>())</td></tr>
<tr class="separator:a999fd9c72081111a7dbe943398f6d42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f80a9b59df31e69d467593cca4c2052"><td class="memTemplParams" colspan="2"><a id="a2f80a9b59df31e69d467593cca4c2052" name="a2f80a9b59df31e69d467593cca4c2052"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2f80a9b59df31e69d467593cca4c2052"><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_t&lt;!<a class="el" href="structpybind11_1_1detail_1_1negation.html">detail::move_never</a>&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>move</b> (<a class="el" href="classpybind11_1_1object.html">object</a> &amp;&amp;obj)</td></tr>
<tr class="separator:a2f80a9b59df31e69d467593cca4c2052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00963e71cd4defebe3e54c6c814b384f"><td class="memTemplParams" colspan="2"><a id="a00963e71cd4defebe3e54c6c814b384f" name="a00963e71cd4defebe3e54c6c814b384f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a00963e71cd4defebe3e54c6c814b384f"><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_t&lt; <a class="el" href="structpybind11_1_1detail_1_1move__always.html">detail::move_always</a>&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cast</b> (<a class="el" href="classpybind11_1_1object.html">object</a> &amp;&amp;<a class="el" href="classpybind11_1_1object.html">object</a>)</td></tr>
<tr class="separator:a00963e71cd4defebe3e54c6c814b384f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd933d48028eba5a4227b007e9b78b6"><td class="memTemplParams" colspan="2"><a id="affd933d48028eba5a4227b007e9b78b6" name="affd933d48028eba5a4227b007e9b78b6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:affd933d48028eba5a4227b007e9b78b6"><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_t&lt; <a class="el" href="structpybind11_1_1detail_1_1move__if__unreferenced.html">detail::move_if_unreferenced</a>&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cast</b> (<a class="el" href="classpybind11_1_1object.html">object</a> &amp;&amp;<a class="el" href="classpybind11_1_1object.html">object</a>)</td></tr>
<tr class="separator:affd933d48028eba5a4227b007e9b78b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc52466bbca1c602c2f4b61ff499018"><td class="memTemplParams" colspan="2"><a id="aecc52466bbca1c602c2f4b61ff499018" name="aecc52466bbca1c602c2f4b61ff499018"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aecc52466bbca1c602c2f4b61ff499018"><td class="memTemplItemLeft" align="right" valign="top">detail::enable_if_t&lt; <a class="el" href="structpybind11_1_1detail_1_1negation.html">detail::move_never</a>&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cast</b> (<a class="el" href="classpybind11_1_1object.html">object</a> &amp;&amp;<a class="el" href="classpybind11_1_1object.html">object</a>)</td></tr>
<tr class="separator:aecc52466bbca1c602c2f4b61ff499018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670a887e73ef1198b120f2f7dfe10495"><td class="memItemLeft" align="right" valign="top"><a id="a670a887e73ef1198b120f2f7dfe10495" name="a670a887e73ef1198b120f2f7dfe10495"></a>
cast_error&#160;</td><td class="memItemRight" valign="bottom"><b>cast_error_unable_to_convert_call_arg</b> (const std::string &amp;<a class="el" href="structpybind11_1_1name.html">name</a>, const std::string &amp;<a class="el" href="classpybind11_1_1type.html">type</a>)</td></tr>
<tr class="separator:a670a887e73ef1198b120f2f7dfe10495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e52b4af2513beedc58c660691d96c7"><td class="memTemplParams" colspan="2"><a id="a29e52b4af2513beedc58c660691d96c7" name="a29e52b4af2513beedc58c660691d96c7"></a>
template&lt;<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">return_value_policy</a> policy = return_value_policy::automatic_reference&gt; </td></tr>
<tr class="memitem:a29e52b4af2513beedc58c660691d96c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1tuple.html">tuple</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_tuple</b> ()</td></tr>
<tr class="separator:a29e52b4af2513beedc58c660691d96c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829aea796e8a24212b310db43534c1b7"><td class="memTemplParams" colspan="2"><a id="a829aea796e8a24212b310db43534c1b7" name="a829aea796e8a24212b310db43534c1b7"></a>
template&lt;<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">return_value_policy</a> policy = return_value_policy::automatic_reference, typename... Args&gt; </td></tr>
<tr class="memitem:a829aea796e8a24212b310db43534c1b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1tuple.html">tuple</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_tuple</b> (Args &amp;&amp;... args_)</td></tr>
<tr class="separator:a829aea796e8a24212b310db43534c1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46240bdb807f80caa6e104591878d5c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structpybind11_1_1arg.html">arg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#ad46240bdb807f80caa6e104591878d5c">operator&quot;&quot;_a</a> (const char *<a class="el" href="structpybind11_1_1name.html">name</a>, size_t)</td></tr>
<tr class="separator:ad46240bdb807f80caa6e104591878d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81266f5a149071042f9e257eca8576d6"><td class="memTemplParams" colspan="2"><a id="a81266f5a149071042f9e257eca8576d6" name="a81266f5a149071042f9e257eca8576d6"></a>
template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a81266f5a149071042f9e257eca8576d6"><td class="memTemplItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ssize_t_cast</b> (const IntType &amp;val)</td></tr>
<tr class="separator:a81266f5a149071042f9e257eca8576d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878f069e172da3a77d4bcf171f06711f"><td class="memItemLeft" align="right" valign="top">class __attribute__((visibility(&quot;default&quot;))) stop_iteration class __attribute__((visibility(&quot;default&quot;))) index_error class __attribute__((visibility(&quot;default&quot;))) key_error class __attribute__((visibility(&quot;default&quot;))) value_error class __attribute__((visibility(&quot;default&quot;))) type_error class __attribute__((visibility(&quot;default&quot;))) buffer_error class __attribute__((visibility(&quot;default&quot;))) import_error class __attribute__((visibility(&quot;default&quot;))) attribute_error class __attribute__((visibility(&quot;default&quot;))) cast_error class __attribute__((visibility(&quot;default&quot;))) reference_cast_error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a878f069e172da3a77d4bcf171f06711f">__attribute__</a> ((noinline)) inline void pybind11_fail(const char *reason)</td></tr>
<tr class="memdesc:a878f069e172da3a77d4bcf171f06711f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when pybind11::cast or handle::call fail due to a type casting error.  <a href="namespacepybind11.html#a878f069e172da3a77d4bcf171f06711f">More...</a><br /></td></tr>
<tr class="separator:a878f069e172da3a77d4bcf171f06711f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f34e561cd9a59c724b56e86242a30f1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5f34e561cd9a59c724b56e86242a30f1"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a5f34e561cd9a59c724b56e86242a30f1">get_or_create_shared_data</a> (const std::string &amp;<a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:a5f34e561cd9a59c724b56e86242a30f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc4ff2c95fc8fbefad4918022ccf21d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a6fc4ff2c95fc8fbefad4918022ccf21d">initialize_interpreter</a> (bool init_signal_handlers=true, int argc=0, const char *const *argv=nullptr, bool add_program_dir_to_path=true)</td></tr>
<tr class="separator:a6fc4ff2c95fc8fbefad4918022ccf21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f49a19c03be57ee8ff8427a5f30dc20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a2f49a19c03be57ee8ff8427a5f30dc20">finalize_interpreter</a> ()</td></tr>
<tr class="separator:a2f49a19c03be57ee8ff8427a5f30dc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3981d01e4cee9ffe917423a47e74b28a"><td class="memTemplParams" colspan="2"><a id="a3981d01e4cee9ffe917423a47e74b28a" name="a3981d01e4cee9ffe917423a47e74b28a"></a>
template&lt;<a class="el" href="namespacepybind11.html#a08a5898f9a083026531bc5d435f715ea">eval_mode</a> mode = eval_expr&gt; </td></tr>
<tr class="memitem:a3981d01e4cee9ffe917423a47e74b28a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eval</b> (const <a class="el" href="classpybind11_1_1str.html">str</a> &amp;expr, <a class="el" href="classpybind11_1_1object.html">object</a> global=<a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a>(), <a class="el" href="classpybind11_1_1object.html">object</a> local=<a class="el" href="classpybind11_1_1object.html">object</a>())</td></tr>
<tr class="separator:a3981d01e4cee9ffe917423a47e74b28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b1a96dad971e6c0edd9b796cc57880"><td class="memTemplParams" colspan="2"><a id="a56b1a96dad971e6c0edd9b796cc57880" name="a56b1a96dad971e6c0edd9b796cc57880"></a>
template&lt;<a class="el" href="namespacepybind11.html#a08a5898f9a083026531bc5d435f715ea">eval_mode</a> mode = eval_expr, size_t N&gt; </td></tr>
<tr class="memitem:a56b1a96dad971e6c0edd9b796cc57880"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eval</b> (const char(&amp;s)[N], <a class="el" href="classpybind11_1_1object.html">object</a> global=<a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a>(), <a class="el" href="classpybind11_1_1object.html">object</a> local=<a class="el" href="classpybind11_1_1object.html">object</a>())</td></tr>
<tr class="separator:a56b1a96dad971e6c0edd9b796cc57880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11117d5df9c76fb1fabba766a6edd21"><td class="memItemLeft" align="right" valign="top"><a id="aa11117d5df9c76fb1fabba766a6edd21" name="aa11117d5df9c76fb1fabba766a6edd21"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>exec</b> (const <a class="el" href="classpybind11_1_1str.html">str</a> &amp;expr, <a class="el" href="classpybind11_1_1object.html">object</a> global=<a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a>(), <a class="el" href="classpybind11_1_1object.html">object</a> local=<a class="el" href="classpybind11_1_1object.html">object</a>())</td></tr>
<tr class="separator:aa11117d5df9c76fb1fabba766a6edd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38838be20e46edfdb3dbc03f176d7bc"><td class="memTemplParams" colspan="2"><a id="ae38838be20e46edfdb3dbc03f176d7bc" name="ae38838be20e46edfdb3dbc03f176d7bc"></a>
template&lt;size_t N&gt; </td></tr>
<tr class="memitem:ae38838be20e46edfdb3dbc03f176d7bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exec</b> (const char(&amp;s)[N], <a class="el" href="classpybind11_1_1object.html">object</a> global=<a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a>(), <a class="el" href="classpybind11_1_1object.html">object</a> local=<a class="el" href="classpybind11_1_1object.html">object</a>())</td></tr>
<tr class="separator:ae38838be20e46edfdb3dbc03f176d7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3958ed51fe6e4bf962b04e32d01c242"><td class="memTemplParams" colspan="2"><a id="ab3958ed51fe6e4bf962b04e32d01c242" name="ab3958ed51fe6e4bf962b04e32d01c242"></a>
template&lt;<a class="el" href="namespacepybind11.html#a08a5898f9a083026531bc5d435f715ea">eval_mode</a> mode = eval_statements&gt; </td></tr>
<tr class="memitem:ab3958ed51fe6e4bf962b04e32d01c242"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>eval_file</b> (<a class="el" href="classpybind11_1_1str.html">str</a> fname, <a class="el" href="classpybind11_1_1object.html">object</a> global=<a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a>(), <a class="el" href="classpybind11_1_1object.html">object</a> local=<a class="el" href="classpybind11_1_1object.html">object</a>())</td></tr>
<tr class="separator:ab3958ed51fe6e4bf962b04e32d01c242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf27b11ce560c0186d6befa286a914f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1class__.html">class_</a>&lt; <a class="el" href="classpybind11_1_1detail_1_1OstreamRedirect.html">detail::OstreamRedirect</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#acbf27b11ce560c0186d6befa286a914f">add_ostream_redirect</a> (<a class="el" href="classpybind11_1_1module__.html">module_</a> m, const std::string &amp;<a class="el" href="structpybind11_1_1name.html">name</a>=&quot;ostream_redirect&quot;)</td></tr>
<tr class="separator:acbf27b11ce560c0186d6befa286a914f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291bcea432671152a298d90b3a985152"><td class="memTemplParams" colspan="2"><a id="a291bcea432671152a298d90b3a985152" name="a291bcea432671152a298d90b3a985152"></a>
template&lt;typename Return , typename... Args&gt; </td></tr>
<tr class="memitem:a291bcea432671152a298d90b3a985152"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpybind11_1_1detail_1_1vectorize__helper.html">detail::vectorize_helper</a>&lt; Return(*)(Args...), Return, Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vectorize</b> (Return(*f)(Args ...))</td></tr>
<tr class="separator:a291bcea432671152a298d90b3a985152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7db768db7442da913dd254198f0a7dc"><td class="memTemplParams" colspan="2"><a id="ac7db768db7442da913dd254198f0a7dc" name="ac7db768db7442da913dd254198f0a7dc"></a>
template&lt;typename Func , detail::enable_if_t&lt; <a class="el" href="structpybind11_1_1detail_1_1negation.html">detail::is_lambda</a>&lt; Func &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac7db768db7442da913dd254198f0a7dc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vectorize</b> (Func &amp;&amp;f) -&gt; decltype(detail::vectorize_extractor(std::forward&lt; Func &gt;(f),(detail::function_signature_t&lt; Func &gt; *) nullptr))</td></tr>
<tr class="separator:ac7db768db7442da913dd254198f0a7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb3c0b9044e0b0d3e8fc0324f485acf"><td class="memTemplParams" colspan="2"><a id="a1cb3c0b9044e0b0d3e8fc0324f485acf" name="a1cb3c0b9044e0b0d3e8fc0324f485acf"></a>
template&lt;typename Return , typename Class , typename... Args, typename Helper  = detail::vectorize_helper&lt;decltype(std::mem_fn(std::declval&lt;Return (Class::*)(Args...)&gt;())), Return, Class *, Args...&gt;&gt; </td></tr>
<tr class="memitem:a1cb3c0b9044e0b0d3e8fc0324f485acf"><td class="memTemplItemLeft" align="right" valign="top">Helper&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vectorize</b> (Return(Class::*f)(Args...))</td></tr>
<tr class="separator:a1cb3c0b9044e0b0d3e8fc0324f485acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4397f2663d6784bd53630fc5a23c02a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1dict.html">dict</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#gaf4397f2663d6784bd53630fc5a23c02a">globals</a> ()</td></tr>
<tr class="separator:gaf4397f2663d6784bd53630fc5a23c02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80923cbfeaa7668191f479b40a94957e"><td class="memTemplParams" colspan="2">template&lt;typename , typename F &gt; </td></tr>
<tr class="memitem:a80923cbfeaa7668191f479b40a94957e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a80923cbfeaa7668191f479b40a94957e">method_adaptor</a> (F &amp;&amp;f) -&gt; decltype(std::forward&lt; F &gt;(f))</td></tr>
<tr class="separator:a80923cbfeaa7668191f479b40a94957e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb36fd4bbf6d949769e083dc9bdf7426"><td class="memTemplParams" colspan="2"><a id="aeb36fd4bbf6d949769e083dc9bdf7426" name="aeb36fd4bbf6d949769e083dc9bdf7426"></a>
template&lt;typename Derived , typename Return , typename Class , typename... Args&gt; </td></tr>
<tr class="memitem:aeb36fd4bbf6d949769e083dc9bdf7426"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>method_adaptor</b> (Return(Class::*pmf)(Args...)) -&gt; Return(Derived::*)(Args...)</td></tr>
<tr class="separator:aeb36fd4bbf6d949769e083dc9bdf7426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5cc0e57262ee3d389d15691a08e25c"><td class="memTemplParams" colspan="2"><a id="abe5cc0e57262ee3d389d15691a08e25c" name="abe5cc0e57262ee3d389d15691a08e25c"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abe5cc0e57262ee3d389d15691a08e25c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpybind11_1_1detail_1_1initimpl_1_1constructor.html">detail::initimpl::constructor</a>&lt; Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>init</b> ()</td></tr>
<tr class="memdesc:abe5cc0e57262ee3d389d15691a08e25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds an existing constructor taking arguments Args... <br /></td></tr>
<tr class="separator:abe5cc0e57262ee3d389d15691a08e25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c2c55812897c3093bce41fdabc2c6a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a69c2c55812897c3093bce41fdabc2c6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpybind11_1_1detail_1_1initimpl_1_1alias__constructor.html">detail::initimpl::alias_constructor</a>&lt; Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a69c2c55812897c3093bce41fdabc2c6a">init_alias</a> ()</td></tr>
<tr class="separator:a69c2c55812897c3093bce41fdabc2c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72b540437b1862d453598570dfe93d6"><td class="memTemplParams" colspan="2"><a id="aa72b540437b1862d453598570dfe93d6" name="aa72b540437b1862d453598570dfe93d6"></a>
template&lt;typename Func , typename Ret  = detail::initimpl::factory&lt;Func&gt;&gt; </td></tr>
<tr class="memitem:aa72b540437b1862d453598570dfe93d6"><td class="memTemplItemLeft" align="right" valign="top">Ret&#160;</td><td class="memTemplItemRight" valign="bottom"><b>init</b> (Func &amp;&amp;f)</td></tr>
<tr class="memdesc:aa72b540437b1862d453598570dfe93d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a factory function as a constructor. <br /></td></tr>
<tr class="separator:aa72b540437b1862d453598570dfe93d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d4d82f9a77e15999d0d7698252465d"><td class="memTemplParams" colspan="2">template&lt;typename CFunc , typename AFunc , typename Ret  = detail::initimpl::factory&lt;CFunc, AFunc&gt;&gt; </td></tr>
<tr class="memitem:af1d4d82f9a77e15999d0d7698252465d"><td class="memTemplItemLeft" align="right" valign="top">Ret&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#af1d4d82f9a77e15999d0d7698252465d">init</a> (CFunc &amp;&amp;c, AFunc &amp;&amp;a)</td></tr>
<tr class="separator:af1d4d82f9a77e15999d0d7698252465d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68578cd3662c92e68bb1fdd8f0efa318"><td class="memTemplParams" colspan="2">template&lt;typename GetState , typename SetState &gt; </td></tr>
<tr class="memitem:a68578cd3662c92e68bb1fdd8f0efa318"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structpybind11_1_1detail_1_1initimpl_1_1pickle__factory.html">detail::initimpl::pickle_factory</a>&lt; GetState, SetState &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a68578cd3662c92e68bb1fdd8f0efa318">pickle</a> (GetState &amp;&amp;g, SetState &amp;&amp;s)</td></tr>
<tr class="separator:a68578cd3662c92e68bb1fdd8f0efa318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97330a2a87d0653768770751b057c5e"><td class="memTemplParams" colspan="2"><a id="ac97330a2a87d0653768770751b057c5e" name="ac97330a2a87d0653768770751b057c5e"></a>
template&lt;<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">return_value_policy</a> Policy = return_value_policy::reference_internal, typename Iterator , typename Sentinel , typename ValueType  = typename detail::iterator_access&lt;Iterator&gt;::result_type, typename... Extra&gt; </td></tr>
<tr class="memitem:ac97330a2a87d0653768770751b057c5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_iterator</b> (Iterator first, Sentinel last, Extra &amp;&amp;... extra)</td></tr>
<tr class="memdesc:ac97330a2a87d0653768770751b057c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a python iterator from a first and past-the-end C++ InputIterator. <br /></td></tr>
<tr class="separator:ac97330a2a87d0653768770751b057c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ef7b6fc8127e8cde4d39709ddb7f76"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">return_value_policy</a> Policy = return_value_policy::reference_internal, typename Iterator , typename Sentinel , typename KeyType  = typename detail::iterator_key_access&lt;Iterator&gt;::result_type, typename... Extra&gt; </td></tr>
<tr class="memitem:a01ef7b6fc8127e8cde4d39709ddb7f76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a01ef7b6fc8127e8cde4d39709ddb7f76">make_key_iterator</a> (Iterator first, Sentinel last, Extra &amp;&amp;...extra)</td></tr>
<tr class="separator:a01ef7b6fc8127e8cde4d39709ddb7f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0da119518ec7bc8ef60c08538e59c1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">return_value_policy</a> Policy = return_value_policy::reference_internal, typename Iterator , typename Sentinel , typename ValueType  = typename detail::iterator_value_access&lt;Iterator&gt;::result_type, typename... Extra&gt; </td></tr>
<tr class="memitem:a4e0da119518ec7bc8ef60c08538e59c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a4e0da119518ec7bc8ef60c08538e59c1">make_value_iterator</a> (Iterator first, Sentinel last, Extra &amp;&amp;...extra)</td></tr>
<tr class="separator:a4e0da119518ec7bc8ef60c08538e59c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7e251f8927c3f839ec9beff8662a4c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">return_value_policy</a> Policy = return_value_policy::reference_internal, typename Type , typename... Extra&gt; </td></tr>
<tr class="memitem:abc7e251f8927c3f839ec9beff8662a4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#abc7e251f8927c3f839ec9beff8662a4c">make_iterator</a> (Type &amp;value, Extra &amp;&amp;... extra)</td></tr>
<tr class="separator:abc7e251f8927c3f839ec9beff8662a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451a8f82d09d763f5400dead333116ee"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">return_value_policy</a> Policy = return_value_policy::reference_internal, typename Type , typename... Extra&gt; </td></tr>
<tr class="memitem:a451a8f82d09d763f5400dead333116ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a451a8f82d09d763f5400dead333116ee">make_key_iterator</a> (Type &amp;value, Extra &amp;&amp;... extra)</td></tr>
<tr class="separator:a451a8f82d09d763f5400dead333116ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad652bc5920831b4285b7e3899f2dff42"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">return_value_policy</a> Policy = return_value_policy::reference_internal, typename Type , typename... Extra&gt; </td></tr>
<tr class="memitem:ad652bc5920831b4285b7e3899f2dff42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#ad652bc5920831b4285b7e3899f2dff42">make_value_iterator</a> (Type &amp;value, Extra &amp;&amp;... extra)</td></tr>
<tr class="separator:ad652bc5920831b4285b7e3899f2dff42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d4074b855542774c3fbdd75697d48c"><td class="memTemplParams" colspan="2"><a id="aa3d4074b855542774c3fbdd75697d48c" name="aa3d4074b855542774c3fbdd75697d48c"></a>
template&lt;typename InputType , typename OutputType &gt; </td></tr>
<tr class="memitem:aa3d4074b855542774c3fbdd75697d48c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>implicitly_convertible</b> ()</td></tr>
<tr class="separator:aa3d4074b855542774c3fbdd75697d48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34f28689d4d9188f257a7a62e9ea29c"><td class="memItemLeft" align="right" valign="top"><a id="af34f28689d4d9188f257a7a62e9ea29c" name="af34f28689d4d9188f257a7a62e9ea29c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>register_exception_translator</b> (ExceptionTranslator &amp;&amp;translator)</td></tr>
<tr class="separator:af34f28689d4d9188f257a7a62e9ea29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae693d156ecb0265d7c267e65164b3f8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#ae693d156ecb0265d7c267e65164b3f8e">register_local_exception_translator</a> (ExceptionTranslator &amp;&amp;translator)</td></tr>
<tr class="separator:ae693d156ecb0265d7c267e65164b3f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1495dd620c3ab615d1fb16fe6595e47a"><td class="memTemplParams" colspan="2">template&lt;typename CppException &gt; </td></tr>
<tr class="memitem:a1495dd620c3ab615d1fb16fe6595e47a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1exception.html">exception</a>&lt; CppException &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a1495dd620c3ab615d1fb16fe6595e47a">register_exception</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1scope.html">scope</a>, const char *<a class="el" href="structpybind11_1_1name.html">name</a>, <a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1base.html">base</a>=PyExc_Exception)</td></tr>
<tr class="separator:a1495dd620c3ab615d1fb16fe6595e47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac095484e5bd268255fd61a46820f4e0a"><td class="memTemplParams" colspan="2">template&lt;typename CppException &gt; </td></tr>
<tr class="memitem:ac095484e5bd268255fd61a46820f4e0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1exception.html">exception</a>&lt; CppException &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#ac095484e5bd268255fd61a46820f4e0a">register_local_exception</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1scope.html">scope</a>, const char *<a class="el" href="structpybind11_1_1name.html">name</a>, <a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1base.html">base</a>=PyExc_Exception)</td></tr>
<tr class="separator:ac095484e5bd268255fd61a46820f4e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913a30079a57934b1bfda83ba4080da4"><td class="memTemplParams" colspan="2"><a id="a913a30079a57934b1bfda83ba4080da4" name="a913a30079a57934b1bfda83ba4080da4"></a>
template&lt;<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">return_value_policy</a> policy = return_value_policy::automatic_reference, typename... Args&gt; </td></tr>
<tr class="memitem:a913a30079a57934b1bfda83ba4080da4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>print</b> (Args &amp;&amp;...<a class="el" href="classpybind11_1_1args.html">args</a>)</td></tr>
<tr class="separator:a913a30079a57934b1bfda83ba4080da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df2db054670958a2f7ee92947d4c105"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6df2db054670958a2f7ee92947d4c105"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1function.html">function</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a6df2db054670958a2f7ee92947d4c105">get_override</a> (const T *this_ptr, const char *<a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:a6df2db054670958a2f7ee92947d4c105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d891f9c3ddd91e6dd456514e133c924"><td class="memItemLeft" align="right" valign="top"><a id="a8d891f9c3ddd91e6dd456514e133c924" name="a8d891f9c3ddd91e6dd456514e133c924"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b> ((deprecated(&quot;get_type_overload has been deprecated&quot;))) inline <a class="el" href="classpybind11_1_1function.html">function</a> get_type_overload(const void *this_ptr</td></tr>
<tr class="separator:a8d891f9c3ddd91e6dd456514e133c924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf1986e4cc6b7770ee71b3ce88a1a7c"><td class="memTemplParams" colspan="2"><a id="a1bf1986e4cc6b7770ee71b3ce88a1a7c" name="a1bf1986e4cc6b7770ee71b3ce88a1a7c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1bf1986e4cc6b7770ee71b3ce88a1a7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1function.html">function</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_overload</b> (const T *this_ptr, const char *<a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:a1bf1986e4cc6b7770ee71b3ce88a1a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad75b61738e777489ed1f4a30776268"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acad75b61738e777489ed1f4a30776268"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#acad75b61738e777489ed1f4a30776268">reinterpret_borrow</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> h)</td></tr>
<tr class="separator:acad75b61738e777489ed1f4a30776268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8f2939859acb062ae3c38c8b82b9f0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b8f2939859acb062ae3c38c8b82b9f0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a4b8f2939859acb062ae3c38c8b82b9f0">reinterpret_steal</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> h)</td></tr>
<tr class="separator:a4b8f2939859acb062ae3c38c8b82b9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de041115880fe435885b9a9d7c2c276"><td class="memTemplParams" colspan="2">template&lt;typename T , detail::enable_if_t&lt; std::is_base_of&lt; <a class="el" href="classpybind11_1_1object.html">object</a>, T &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga2de041115880fe435885b9a9d7c2c276"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#ga2de041115880fe435885b9a9d7c2c276">isinstance</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj)</td></tr>
<tr class="separator:ga2de041115880fe435885b9a9d7c2c276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c89a0add98761af02c3eca6a9b317f2"><td class="memItemLeft" align="right" valign="top"><a id="a3c89a0add98761af02c3eca6a9b317f2" name="a3c89a0add98761af02c3eca6a9b317f2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3c89a0add98761af02c3eca6a9b317f2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isinstance&lt; handle &gt;</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a>)=delete</td></tr>
<tr class="separator:a3c89a0add98761af02c3eca6a9b317f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc42dbf138ab0de23a58c7952cb8ba9a"><td class="memItemLeft" align="right" valign="top"><a id="adc42dbf138ab0de23a58c7952cb8ba9a" name="adc42dbf138ab0de23a58c7952cb8ba9a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adc42dbf138ab0de23a58c7952cb8ba9a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isinstance&lt; object &gt;</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj)</td></tr>
<tr class="separator:adc42dbf138ab0de23a58c7952cb8ba9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga514d6552530d0b02362a2045f43fcdba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#ga514d6552530d0b02362a2045f43fcdba">isinstance</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, <a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="classpybind11_1_1type.html">type</a>)</td></tr>
<tr class="separator:ga514d6552530d0b02362a2045f43fcdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87cc23c83cdeaec183f0a0e4122d9997"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasattr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, <a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:ga87cc23c83cdeaec183f0a0e4122d9997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef7ee96307a4732fad5df956b387f8a8"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasattr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, const char *<a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:gaef7ee96307a4732fad5df956b387f8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5fa715b1b95c90a87372ea6ad4dc78a"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>delattr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, <a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:gaa5fa715b1b95c90a87372ea6ad4dc78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga854c75de22ee024532d54cae1e4dd578"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>delattr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, const char *<a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:ga854c75de22ee024532d54cae1e4dd578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0854324102907dc2d82ac413b6e6b66e"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getattr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, <a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:ga0854324102907dc2d82ac413b6e6b66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac80ddad26eb3426c93277ce8d7c0f982"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getattr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, const char *<a class="el" href="structpybind11_1_1name.html">name</a>)</td></tr>
<tr class="separator:gac80ddad26eb3426c93277ce8d7c0f982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga715c20d77757165563f28474dc39e80c"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getattr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, <a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1name.html">name</a>, <a class="el" href="classpybind11_1_1handle.html">handle</a> default_)</td></tr>
<tr class="separator:ga715c20d77757165563f28474dc39e80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a207d73efa28381746217b7afba118f"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classpybind11_1_1object.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getattr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, const char *<a class="el" href="structpybind11_1_1name.html">name</a>, <a class="el" href="classpybind11_1_1handle.html">handle</a> default_)</td></tr>
<tr class="separator:ga7a207d73efa28381746217b7afba118f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3d54ac3f3614c110d2ffa5c061ee905"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>setattr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, <a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1name.html">name</a>, <a class="el" href="classpybind11_1_1handle.html">handle</a> value)</td></tr>
<tr class="separator:gad3d54ac3f3614c110d2ffa5c061ee905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac63dcad9209e4abd96a430bef04414ce"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>setattr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj, const char *<a class="el" href="structpybind11_1_1name.html">name</a>, <a class="el" href="classpybind11_1_1handle.html">handle</a> value)</td></tr>
<tr class="separator:gac63dcad9209e4abd96a430bef04414ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03ebe43bb70bdbbb9b1f2456ec391429"><td class="memItemLeft" align="right" valign="top">
ssize_t&#160;</td><td class="memItemRight" valign="bottom"><b>hash</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj)</td></tr>
<tr class="separator:ga03ebe43bb70bdbbb9b1f2456ec391429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64ce16d2a0ab3f9e80fdde0e0857224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1str.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#ac64ce16d2a0ab3f9e80fdde0e0857224">operator&quot;&quot;_s</a> (const char *s, size_t size)</td></tr>
<tr class="separator:ac64ce16d2a0ab3f9e80fdde0e0857224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12ce0d6ed5e2a4293c4dbeac09a1ec3b"><td class="memTemplParams" colspan="2">
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga12ce0d6ed5e2a4293c4dbeac09a1ec3b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>args_are_all_keyword_or_ds</b> ()</td></tr>
<tr class="separator:ga12ce0d6ed5e2a4293c4dbeac09a1ec3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga443ea89aee29c1a3b9d57324d4d089b6"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>len</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> h)</td></tr>
<tr class="memdesc:ga443ea89aee29c1a3b9d57324d4d089b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of a Python object. <br /></td></tr>
<tr class="separator:ga443ea89aee29c1a3b9d57324d4d089b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20a0506650aedafad61466d5c933b19e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__python__builtins.html#ga20a0506650aedafad61466d5c933b19e">len_hint</a> (<a class="el" href="classpybind11_1_1handle.html">handle</a> h)</td></tr>
<tr class="separator:ga20a0506650aedafad61466d5c933b19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad03802ec7d35cdd35a26c59cd53db480"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classpybind11_1_1str.html">str</a>&#160;</td><td class="memItemRight" valign="bottom"><b>repr</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> h)</td></tr>
<tr class="separator:gad03802ec7d35cdd35a26c59cd53db480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4e8cc0cdd5b04fd00f4ba1f2d0f5b8d"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classpybind11_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iter</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> obj)</td></tr>
<tr class="separator:gab4e8cc0cdd5b04fd00f4ba1f2d0f5b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b51424890152f871e5af565e2cb708f"><td class="memItemLeft" align="right" valign="top"><a id="a5b51424890152f871e5af565e2cb708f" name="a5b51424890152f871e5af565e2cb708f"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classpybind11_1_1handle.html">handle</a> &amp;obj)</td></tr>
<tr class="separator:a5b51424890152f871e5af565e2cb708f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68495845c6ab59a205c46aee15f5b28"><td class="memTemplParams" colspan="2"><a id="ab68495845c6ab59a205c46aee15f5b28" name="ab68495845c6ab59a205c46aee15f5b28"></a>
template&lt;typename Vector , typename holder_type  = std::unique_ptr&lt;Vector&gt;, typename... Args&gt; </td></tr>
<tr class="memitem:ab68495845c6ab59a205c46aee15f5b28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1class__.html">class_</a>&lt; Vector, holder_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bind_vector</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1scope.html">scope</a>, std::string const &amp;<a class="el" href="structpybind11_1_1name.html">name</a>, Args &amp;&amp;... <a class="el" href="classpybind11_1_1args.html">args</a>)</td></tr>
<tr class="separator:ab68495845c6ab59a205c46aee15f5b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff524bb40c17e312354a1e31fd6d9f9"><td class="memTemplParams" colspan="2"><a id="abff524bb40c17e312354a1e31fd6d9f9" name="abff524bb40c17e312354a1e31fd6d9f9"></a>
template&lt;typename Map , typename holder_type  = std::unique_ptr&lt;Map&gt;, typename... Args&gt; </td></tr>
<tr class="memitem:abff524bb40c17e312354a1e31fd6d9f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpybind11_1_1class__.html">class_</a>&lt; Map, holder_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bind_map</b> (<a class="el" href="classpybind11_1_1handle.html">handle</a> <a class="el" href="structpybind11_1_1scope.html">scope</a>, const std::string &amp;<a class="el" href="structpybind11_1_1name.html">name</a>, Args &amp;&amp;... <a class="el" href="classpybind11_1_1args.html">args</a>)</td></tr>
<tr class="separator:abff524bb40c17e312354a1e31fd6d9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7afff4b33ed1587b44716947e6260020"><td class="memItemLeft" align="right" valign="top"><a id="a7afff4b33ed1587b44716947e6260020" name="a7afff4b33ed1587b44716947e6260020"></a>
const <a class="el" href="structpybind11_1_1detail_1_1type__info.html">detail::type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>this_type</b></td></tr>
<tr class="separator:a7afff4b33ed1587b44716947e6260020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6c7ea3a45d3dc0689f9cde5013933f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpybind11_1_1detail_1_1type__info.html">detail::type_info</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepybind11.html#a6e6c7ea3a45d3dc0689f9cde5013933f">name</a></td></tr>
<tr class="separator:a6e6c7ea3a45d3dc0689f9cde5013933f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >glibc defines I as a macro which breaks things, e.g., boost template names </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a08a5898f9a083026531bc5d435f715ea" name="a08a5898f9a083026531bc5d435f715ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a5898f9a083026531bc5d435f715ea">&#9670;&nbsp;</a></span>eval_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepybind11.html#a08a5898f9a083026531bc5d435f715ea">pybind11::eval_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a08a5898f9a083026531bc5d435f715eaa86e05cca1e5516b3ff4014f9af34aaff" name="a08a5898f9a083026531bc5d435f715eaa86e05cca1e5516b3ff4014f9af34aaff"></a>eval_expr&#160;</td><td class="fielddoc"><p >Evaluate a string containing an isolated expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a08a5898f9a083026531bc5d435f715eaa9cf39a293befe652b5046b1e7cf9fe58" name="a08a5898f9a083026531bc5d435f715eaa9cf39a293befe652b5046b1e7cf9fe58"></a>eval_single_statement&#160;</td><td class="fielddoc"><p >Evaluate a string containing a single statement. Returns <code>none</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a08a5898f9a083026531bc5d435f715eaa22b140993f208620cf25bba6e0d5590b" name="a08a5898f9a083026531bc5d435f715eaa22b140993f208620cf25bba6e0d5590b"></a>eval_statements&#160;</td><td class="fielddoc"><p >Evaluate a string containing a sequence of statement. Returns <code>none</code>. </p>
</td></tr>
</table>

</div>
</div>
<a id="a5f83e7a05cee9068927633ac47dbe69c" name="a5f83e7a05cee9068927633ac47dbe69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f83e7a05cee9068927633ac47dbe69c">&#9670;&nbsp;</a></span>return_value_policy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">pybind11::return_value_policy</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approach used to cast a previously unknown C++ instance into a Python object. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5f83e7a05cee9068927633ac47dbe69ca2bd9c0ed00116be1258e0cc66617d7c8" name="a5f83e7a05cee9068927633ac47dbe69ca2bd9c0ed00116be1258e0cc66617d7c8"></a>automatic&#160;</td><td class="fielddoc"><p >This is the default return value policy, which falls back to the policy <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69ca5dc4bb19391b04351f49572019c628c0">return_value_policy::take_ownership</a> when the return value is a pointer. Otherwise, it uses return_value::move or return_value::copy for rvalue and lvalue references, respectively. See below for a description of what all of these different policies do. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f83e7a05cee9068927633ac47dbe69ca1c1628c22d69b3b9bac4b5c3674852e3" name="a5f83e7a05cee9068927633ac47dbe69ca1c1628c22d69b3b9bac4b5c3674852e3"></a>automatic_reference&#160;</td><td class="fielddoc"><p >As above, but use policy <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69cab8af13ea9c8fe890c9979a1fa8dbde22">return_value_policy::reference</a> when the return value is a pointer. This is the default conversion policy for function arguments when calling Python functions manually from C++ code (i.e. via handle::operator()). You probably won't need to use this. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f83e7a05cee9068927633ac47dbe69ca5dc4bb19391b04351f49572019c628c0" name="a5f83e7a05cee9068927633ac47dbe69ca5dc4bb19391b04351f49572019c628c0"></a>take_ownership&#160;</td><td class="fielddoc"><p >Reference an existing object (i.e. do not create a new copy) and take ownership. Python will call the destructor and delete operator when the object’s reference count reaches zero. Undefined behavior ensues when the C++ side does the same.. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f83e7a05cee9068927633ac47dbe69ca12cba3ee81cf4a793796a51b6327c678" name="a5f83e7a05cee9068927633ac47dbe69ca12cba3ee81cf4a793796a51b6327c678"></a>copy&#160;</td><td class="fielddoc"><p >Create a new copy of the returned object, which will be owned by Python. This policy is comparably safe because the lifetimes of the two instances are decoupled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f83e7a05cee9068927633ac47dbe69ca3734a903022249b3010be1897042568e" name="a5f83e7a05cee9068927633ac47dbe69ca3734a903022249b3010be1897042568e"></a>move&#160;</td><td class="fielddoc"><p >Use std::move to move the return value contents into a new instance that will be owned by Python. This policy is comparably safe because the lifetimes of the two instances (move source and destination) are decoupled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f83e7a05cee9068927633ac47dbe69cab8af13ea9c8fe890c9979a1fa8dbde22" name="a5f83e7a05cee9068927633ac47dbe69cab8af13ea9c8fe890c9979a1fa8dbde22"></a>reference&#160;</td><td class="fielddoc"><p >Reference an existing object, but do not take ownership. The C++ side is responsible for managing the object’s lifetime and deallocating it when it is no longer used. Warning: undefined behavior will ensue when the C++ side deletes an object that is still referenced and used by Python. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f83e7a05cee9068927633ac47dbe69caa39bc0596cb125c1605a78fbd287df7f" name="a5f83e7a05cee9068927633ac47dbe69caa39bc0596cb125c1605a78fbd287df7f"></a>reference_internal&#160;</td><td class="fielddoc"><p >This policy only applies to methods and properties. It references the object without taking ownership similar to the above <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69cab8af13ea9c8fe890c9979a1fa8dbde22">return_value_policy::reference</a> policy. In contrast to that policy, the function or property’s implicit this argument (called the parent) is considered to be the the owner of the return value (the child). <a class="el" href="namespacepybind11.html" title="glibc defines I as a macro which breaks things, e.g., boost template names">pybind11</a> then couples the lifetime of the parent to the child via a reference relationship that ensures that the parent cannot be garbage collected while Python is still using the child. More advanced variations of this scheme are also possible using combinations of <a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69cab8af13ea9c8fe890c9979a1fa8dbde22">return_value_policy::reference</a> and the <a class="el" href="structpybind11_1_1keep__alive.html" title="Keep patient alive while nurse lives.">keep_alive</a> call policy </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a878f069e172da3a77d4bcf171f06711f" name="a878f069e172da3a77d4bcf171f06711f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878f069e172da3a77d4bcf171f06711f">&#9670;&nbsp;</a></span>__attribute__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pybind11::__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(noinline)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thrown when pybind11::cast or handle::call fail due to a type casting error. </p>
<p >Set the shared data that can be later recovered by <code>get_shared_data()</code>.</p>
<p >Used internally</p>
<p >Returns a named pointer that is shared among all extension modules (using the same <a class="el" href="namespacepybind11.html" title="glibc defines I as a macro which breaks things, e.g., boost template names">pybind11</a> version) running in the current interpreter. Names starting with underscores are reserved for internal usage. Returns <code>nullptr</code> if no matching entry was found. </p>

</div>
</div>
<a id="acbf27b11ce560c0186d6befa286a914f" name="acbf27b11ce560c0186d6befa286a914f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf27b11ce560c0186d6befa286a914f">&#9670;&nbsp;</a></span>add_ostream_redirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1class__.html">class_</a>&lt; <a class="el" href="classpybind11_1_1detail_1_1OstreamRedirect.html">detail::OstreamRedirect</a> &gt; pybind11::add_ostream_redirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1module__.html">module_</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ostream_redirect&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >\rst This is a helper function to add a C++ redirect context manager to Python instead of using a C++ guard. To use it, add the following to your binding code:</p>
<p >.. code-block:: cpp </p><pre class="fragment">#include &lt;pybind11/iostream.h&gt;

...

py::add_ostream_redirect(m, "ostream_redirect");
</pre><p> You now have a Python context manager that redirects your output:</p>
<p >.. code-block:: python </p><pre class="fragment">with m.ostream_redirect():
    m.print_to_cout_function()
</pre><p> This manager can optionally be told which streams to operate on:</p>
<p >.. code-block:: python </p><pre class="fragment">with m.ostream_redirect(stdout=true, stderr=true):
    m.noisy_function_with_error_printing()
</pre><p> \endrst </p>

</div>
</div>
<a id="a2f49a19c03be57ee8ff8427a5f30dc20" name="a2f49a19c03be57ee8ff8427a5f30dc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f49a19c03be57ee8ff8427a5f30dc20">&#9670;&nbsp;</a></span>finalize_interpreter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pybind11::finalize_interpreter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >\rst Shut down the Python interpreter. No <a class="el" href="namespacepybind11.html" title="glibc defines I as a macro which breaks things, e.g., boost template names">pybind11</a> or CPython API functions can be called after this. In addition, <a class="el" href="namespacepybind11.html" title="glibc defines I as a macro which breaks things, e.g., boost template names">pybind11</a> objects must not outlive the interpreter:</p>
<p >.. code-block:: cpp </p><pre class="fragment">{ // BAD
    py::initialize_interpreter();
    auto hello = py::str("Hello, World!");
    py::finalize_interpreter();
} // &lt;-- BOOM, hello's destructor is called after interpreter shutdown

{ // GOOD
    py::initialize_interpreter();
    { // scoped
        auto hello = py::str("Hello, World!");
    } // &lt;-- OK, hello is cleaned up properly
    py::finalize_interpreter();
}

{ // BETTER
    py::scoped_interpreter guard{};
    auto hello = py::str("Hello, World!");
}
</pre><p> .. warning:: </p><pre class="fragment">The interpreter can be restarted by calling `initialize_interpreter` again.
Modules created using pybind11 can be safely re-initialized. However, Python
itself cannot completely unload binary extension modules and there are several
caveats with regard to interpreter restarting. All the details can be found
in the CPython documentation. In short, not all interpreter memory may be
freed, either due to reference cycles or user-created global data.
</pre><p> \endrst </p>

</div>
</div>
<a id="a5f34e561cd9a59c724b56e86242a30f1" name="a5f34e561cd9a59c724b56e86242a30f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f34e561cd9a59c724b56e86242a30f1">&#9670;&nbsp;</a></span>get_or_create_shared_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; pybind11::get_or_create_shared_data </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a typed reference to a shared data entry (by using <code>get_shared_data()</code>) if such entry exists. Otherwise, a new object of default-constructible type <code>T</code> is added to the shared data under the given name and a reference to it is returned. </p>

</div>
</div>
<a id="a6df2db054670958a2f7ee92947d4c105" name="a6df2db054670958a2f7ee92947d4c105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df2db054670958a2f7ee92947d4c105">&#9670;&nbsp;</a></span>get_override()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1function.html">function</a> pybind11::get_override </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>this_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >\rst Try to retrieve a python method by the provided name from the instance pointed to by the this_ptr.</p>
<p >:this_ptr: The pointer to the object the overridden method should be retrieved for. This should be the first non-trampoline class encountered in the inheritance chain. :name: The name of the overridden Python method to retrieve. :return: The Python method by this name from the object or an empty function wrapper. \endrst </p>

</div>
</div>
<a id="af1d4d82f9a77e15999d0d7698252465d" name="af1d4d82f9a77e15999d0d7698252465d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d4d82f9a77e15999d0d7698252465d">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CFunc , typename AFunc , typename Ret  = detail::initimpl::factory&lt;CFunc, AFunc&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Ret pybind11::init </td>
          <td>(</td>
          <td class="paramtype">CFunc &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AFunc &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Dual-argument factory function: the first function is called when no alias is needed, the second when an alias is needed (i.e. due to python-side inheritance). Arguments must be identical. </p>

</div>
</div>
<a id="a69c2c55812897c3093bce41fdabc2c6a" name="a69c2c55812897c3093bce41fdabc2c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c2c55812897c3093bce41fdabc2c6a">&#9670;&nbsp;</a></span>init_alias()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpybind11_1_1detail_1_1initimpl_1_1alias__constructor.html">detail::initimpl::alias_constructor</a>&lt; Args... &gt; pybind11::init_alias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Like <code>init&lt;Args...&gt;()</code>, but the instance is always constructed through the alias class (even when not inheriting on the Python side). </p>

</div>
</div>
<a id="a6fc4ff2c95fc8fbefad4918022ccf21d" name="a6fc4ff2c95fc8fbefad4918022ccf21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc4ff2c95fc8fbefad4918022ccf21d">&#9670;&nbsp;</a></span>initialize_interpreter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pybind11::initialize_interpreter </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init_signal_handlers</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>argv</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_program_dir_to_path</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >\rst Initialize the Python interpreter. No other <a class="el" href="namespacepybind11.html" title="glibc defines I as a macro which breaks things, e.g., boost template names">pybind11</a> or CPython API functions can be called before this is done; with the exception of <code>PYBIND11_EMBEDDED_MODULE</code>. The optional <code>init_signal_handlers</code> parameter can be used to skip the registration of signal handlers (see the <code>Python documentation</code>_ for details). Calling this function again after the interpreter has already been initialized is a fatal error.</p>
<p >If initializing the Python interpreter fails, then the program is terminated. (This is controlled by the CPython runtime and is an exception to <a class="el" href="namespacepybind11.html" title="glibc defines I as a macro which breaks things, e.g., boost template names">pybind11</a>'s normal behavior of throwing exceptions on errors.)</p>
<p >The remaining optional parameters, <code>argc</code>, <code>argv</code>, and <code>add_program_dir_to_path</code> are used to populate <code>sys.argv</code> and <code>sys.path</code>. See the |PySys_SetArgvEx documentation|_ for details.</p>
<p >.. _Python documentation: <a href="https://docs.python.org/3/c-api/init.html#c.Py_InitializeEx">https://docs.python.org/3/c-api/init.html#c.Py_InitializeEx</a> .. |PySys_SetArgvEx documentation| replace:: <code>PySys_SetArgvEx</code> documentation .. _PySys_SetArgvEx documentation: <a href="https://docs.python.org/3/c-api/init.html#c.PySys_SetArgvEx">https://docs.python.org/3/c-api/init.html#c.PySys_SetArgvEx</a> \endrst </p>

</div>
</div>
<a id="abc7e251f8927c3f839ec9beff8662a4c" name="abc7e251f8927c3f839ec9beff8662a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7e251f8927c3f839ec9beff8662a4c">&#9670;&nbsp;</a></span>make_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">return_value_policy</a> Policy = return_value_policy::reference_internal, typename Type , typename... Extra&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1iterator.html">iterator</a> pybind11::make_iterator </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Makes an iterator over values of an stl container or other container supporting <code>std::begin()</code>/<code>std::end()</code> </p>

</div>
</div>
<a id="a01ef7b6fc8127e8cde4d39709ddb7f76" name="a01ef7b6fc8127e8cde4d39709ddb7f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ef7b6fc8127e8cde4d39709ddb7f76">&#9670;&nbsp;</a></span>make_key_iterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">return_value_policy</a> Policy = return_value_policy::reference_internal, typename Iterator , typename Sentinel , typename KeyType  = typename detail::iterator_key_access&lt;Iterator&gt;::result_type, typename... Extra&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1iterator.html">iterator</a> pybind11::make_key_iterator </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sentinel&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Makes a python iterator over the keys (<code>.first</code>) of a iterator over pairs from a first and past-the-end InputIterator. </p>

</div>
</div>
<a id="a451a8f82d09d763f5400dead333116ee" name="a451a8f82d09d763f5400dead333116ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451a8f82d09d763f5400dead333116ee">&#9670;&nbsp;</a></span>make_key_iterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">return_value_policy</a> Policy = return_value_policy::reference_internal, typename Type , typename... Extra&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1iterator.html">iterator</a> pybind11::make_key_iterator </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Makes an iterator over the keys (<code>.first</code>) of a stl map-like container supporting <code>std::begin()</code>/<code>std::end()</code> </p>

</div>
</div>
<a id="a4e0da119518ec7bc8ef60c08538e59c1" name="a4e0da119518ec7bc8ef60c08538e59c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0da119518ec7bc8ef60c08538e59c1">&#9670;&nbsp;</a></span>make_value_iterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">return_value_policy</a> Policy = return_value_policy::reference_internal, typename Iterator , typename Sentinel , typename ValueType  = typename detail::iterator_value_access&lt;Iterator&gt;::result_type, typename... Extra&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1iterator.html">iterator</a> pybind11::make_value_iterator </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sentinel&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Makes a python iterator over the values (<code>.second</code>) of a iterator over pairs from a first and past-the-end InputIterator. </p>

</div>
</div>
<a id="ad652bc5920831b4285b7e3899f2dff42" name="ad652bc5920831b4285b7e3899f2dff42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad652bc5920831b4285b7e3899f2dff42">&#9670;&nbsp;</a></span>make_value_iterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacepybind11.html#a5f83e7a05cee9068927633ac47dbe69c">return_value_policy</a> Policy = return_value_policy::reference_internal, typename Type , typename... Extra&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1iterator.html">iterator</a> pybind11::make_value_iterator </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Makes an iterator over the values (<code>.second</code>) of a stl map-like container supporting <code>std::begin()</code>/<code>std::end()</code> </p>

</div>
</div>
<a id="a80923cbfeaa7668191f479b40a94957e" name="a80923cbfeaa7668191f479b40a94957e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80923cbfeaa7668191f479b40a94957e">&#9670;&nbsp;</a></span>method_adaptor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto pybind11::method_adaptor </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; decltype(std::forward&lt;F&gt;(f)) </td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Given a pointer to a member function, cast it to its <code>Derived</code> version. Forward everything else unchanged. </p>

</div>
</div>
<a id="ad46240bdb807f80caa6e104591878d5c" name="ad46240bdb807f80caa6e104591878d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46240bdb807f80caa6e104591878d5c">&#9670;&nbsp;</a></span>operator&quot;&quot;_a()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structpybind11_1_1arg.html">arg</a> pybind11::literals::operator&quot;&quot;_a </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >\rst String literal version of <code>arg</code> \endrst </p>

</div>
</div>
<a id="ac64ce16d2a0ab3f9e80fdde0e0857224" name="ac64ce16d2a0ab3f9e80fdde0e0857224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64ce16d2a0ab3f9e80fdde0e0857224">&#9670;&nbsp;</a></span>operator&quot;&quot;_s()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1str.html">str</a> pybind11::literals::operator&quot;&quot;_s </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >\rst String literal version of <code>str</code> \endrst </p>

</div>
</div>
<a id="a68578cd3662c92e68bb1fdd8f0efa318" name="a68578cd3662c92e68bb1fdd8f0efa318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68578cd3662c92e68bb1fdd8f0efa318">&#9670;&nbsp;</a></span>pickle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GetState , typename SetState &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpybind11_1_1detail_1_1initimpl_1_1pickle__factory.html">detail::initimpl::pickle_factory</a>&lt; GetState, SetState &gt; pybind11::pickle </td>
          <td>(</td>
          <td class="paramtype">GetState &amp;&amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SetState &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Binds pickling functions <code>__getstate__</code> and <code>__setstate__</code> and ensures that the type returned by <code>__getstate__</code> is the same as the argument accepted by <code>__setstate__</code>. </p>

</div>
</div>
<a id="a1495dd620c3ab615d1fb16fe6595e47a" name="a1495dd620c3ab615d1fb16fe6595e47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1495dd620c3ab615d1fb16fe6595e47a">&#9670;&nbsp;</a></span>register_exception()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CppException &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1exception.html">exception</a>&lt; CppException &gt; &amp; pybind11::register_exception </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1handle.html">handle</a>&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1handle.html">handle</a>&#160;</td>
          <td class="paramname"><em>base</em> = <code>PyExc_Exception</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Registers a Python exception in <code>m</code> of the given <code>name</code> and installs a translator to translate the C++ exception to the created Python exception using the what() method. This is intended for simple exception translations; for more complex translation, register the exception object and translator directly. </p>

</div>
</div>
<a id="ac095484e5bd268255fd61a46820f4e0a" name="ac095484e5bd268255fd61a46820f4e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac095484e5bd268255fd61a46820f4e0a">&#9670;&nbsp;</a></span>register_local_exception()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CppException &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpybind11_1_1exception.html">exception</a>&lt; CppException &gt; &amp; pybind11::register_local_exception </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1handle.html">handle</a>&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1handle.html">handle</a>&#160;</td>
          <td class="paramname"><em>base</em> = <code>PyExc_Exception</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Registers a Python exception in <code>m</code> of the given <code>name</code> and installs a translator to translate the C++ exception to the created Python exception using the what() method. This translator will only be used for exceptions that are thrown in this module and will be tried before global exception translators, including those registered with register_exception. This is intended for simple exception translations; for more complex translation, register the exception object and translator directly. </p>

</div>
</div>
<a id="ae693d156ecb0265d7c267e65164b3f8e" name="ae693d156ecb0265d7c267e65164b3f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae693d156ecb0265d7c267e65164b3f8e">&#9670;&nbsp;</a></span>register_local_exception_translator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pybind11::register_local_exception_translator </td>
          <td>(</td>
          <td class="paramtype">ExceptionTranslator &amp;&amp;&#160;</td>
          <td class="paramname"><em>translator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Add a new module-local exception translator. Locally registered functions will be tried before any globally registered exception translators, which will only be invoked if the module-local handlers do not deal with the exception. </p>

</div>
</div>
<a id="acad75b61738e777489ed1f4a30776268" name="acad75b61738e777489ed1f4a30776268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad75b61738e777489ed1f4a30776268">&#9670;&nbsp;</a></span>reinterpret_borrow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pybind11::reinterpret_borrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1handle.html">handle</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >\rst Declare that a <code>handle</code> or <code>PyObject *</code> is a certain type and borrow the reference. The target type <code>T</code> must be <code>object</code> or one of its derived classes. The function doesn't do any conversions or checks. It's up to the user to make sure that the target type is correct.</p>
<p >.. code-block:: cpp </p><pre class="fragment">PyObject *p = PyList_GetItem(obj, index);
py::object o = reinterpret_borrow&lt;py::object&gt;(p);
</pre><p> or py::tuple t = reinterpret_borrow&lt;py::tuple&gt;(p); // &lt;&ndash; <code>p</code> must be already be a <code>tuple</code> \endrst </p>

</div>
</div>
<a id="a4b8f2939859acb062ae3c38c8b82b9f0" name="a4b8f2939859acb062ae3c38c8b82b9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8f2939859acb062ae3c38c8b82b9f0">&#9670;&nbsp;</a></span>reinterpret_steal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T pybind11::reinterpret_steal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpybind11_1_1handle.html">handle</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >\rst Like <code>reinterpret_borrow</code>, but steals the reference.</p>
<p >.. code-block:: cpp</p>
<p >PyObject *p = PyObject_Str(obj); py::str s = reinterpret_steal&lt;py::str&gt;(p); // &lt;&ndash; <code>p</code> must be already be a <code>str</code> \endrst </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6e6c7ea3a45d3dc0689f9cde5013933f" name="a6e6c7ea3a45d3dc0689f9cde5013933f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6c7ea3a45d3dc0689f9cde5013933f">&#9670;&nbsp;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpybind11_1_1detail_1_1type__info.html">detail::type_info</a> const char* <a class="el" href="structpybind11_1_1name.html">pybind11::name</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> detail::get_type_override(this_ptr, this_type, <a class="code hl_struct" href="structpybind11_1_1name.html">name</a>)</div>
<div class="ttc" id="astructpybind11_1_1name_html"><div class="ttname"><a href="structpybind11_1_1name.html">pybind11::name</a></div><div class="ttdoc">Annotation for function names.</div><div class="ttdef"><b>Definition:</b> attr.h:44</div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepybind11.html">pybind11</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
